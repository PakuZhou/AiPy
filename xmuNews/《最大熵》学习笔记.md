##《最大熵》学习笔记
>教程地址：[李航《统计学习方法》第六章——用Python实现最大熵模型（MNIST数据集）](http://blog.csdn.net/wds2006sdo/article/details/53106579)
>学习时间：2017-12-16
>学习环境：Ubuntu 16，Python 3
>笔记作者：PakuZhou

[TOC]
###最大熵模型
假设满足所有约束条件的模型集合为：
$$\mathcal{C}\equiv \{p \in \mathcal{P}|E_P(f_i)=E_{\tilde{P}}(f_i),i=1,2,3,...,n\}$$
定义在条件概率分布$P{Y|X}$上的条件熵为：
$$H(P)=-\sum_{x,y}\tilde{P}(x)P(y | x)logP(y | x)$$
则模型集合$\mathcal{C}$中条件熵$H(P)$最大的模型为最大熵模型。

**联合分布的经验分布：**
$$\tilde{P}(X=x,Y=y)=\frac{v(X=x,Y=y)}{N}$$
$$\tilde{P}(X=x)=\frac{v(X=x)}{N}$$
**特征函数：**
$$f(x,y)=\begin{cases}
1，& \text{x 与 x 满足某一事实}\\
0，& \text{否则}
\end{cases}$$
**特征函数关于模型$P(Y|X)$与经验分布$\tilde{P}(X)$的期望值：**
$$E_P(f)=\sum_{x,y} \tilde{P}(x)P(y|x)f(x,y)$$
**特征函数关于经验分布$\tilde{P}(X,Y)$的期望值：**
$$E_{\tilde{P}}(f)=\sum_{x,y} \tilde{P}(x,y)f(x,y)$$
####优化问题
1.最大熵模型的学习等价于约束最优化问题。
2.将约束最优化问题转换为无约束最优化的对偶问题。（拉格朗日对偶性）
3.对偶函数的极大化等价与最大熵模型的极大似然估计。
最大熵模型
$$\min_{p \in C}-H(P)=\sum_{x,y}\tilde{P}(x)P(y|x)logP(y|x)$$
$$s.t. E_p(f_i)=E_{\tilde{P}}(f_i)$$
$$\sum_yP(y|x)=1$$
对偶：
$$P_w(y|x)=\frac{1}{Z_w(x)}exp(\sum_{i=1}^{n}w_if_i(x,y))$$
其中，
$$Z_w(x)=\sum_{y}exp(\sum_{i=1}^{n}w_if_i(x,y))$$
对数似然函数为
$$L(w)=\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^{n}w_if_i(x,y)-\sum_{x}\tilde{P}(x)logZ_w(x)$$
$$****目标是通过极大似然估计学习模型参数****$$
###算法（IIS）
改进的迭代尺度算法（Improved Iterative Scaling）的想法是：假设最大熵模型当前的参数向量是$w=(w_1,w_2,...,2_n)^T$，我们希望找到一个新的参数向量$w+\delta=(w_1+\delta_1,w_2+\delta_2,...,w_n+\delta_n)^T$，使得模型的对数似然函数值增大。重复该方法直至找到对数似然函数的最大值。
**输入：**特征函数$f_1,f_2,...,f_n$；经验分布$\tilde{P}(X,Y)$，模型$P_w(y|x)$
**输出：**最优参数值$w_i^*$；最有模型$P_{w_i^*}$
**步骤：**
1.对所有$i\in\{1,2,...,n\}$，取初值$w_i=0$
2.对每一$i\in\{1,2,...,n\}$:
==a.令$\delta_i$是下面方程的解
$$\sum_{x,y}\tilde{P}(x)P(y|x)f_i(x,y)exp(\delta_i f^\#(x,y))=E_{\tilde{P}}(f_i)$$
$$f^\#(x,y)=\sum_{i=1}^{n}f_i(x,y)$$
==b.更新$w_i$值：$w_i \leftarrow w_i+\delta_i$
3.如果不是所有的$w_i$都收敛，重复步骤2.
###代码注释
1.由于$f(x,y)$的定义见第82页下方，所以$f^\#(x,y)=M$是一个常数，IIS算法中的$\delta_i$可以由第91页公式（6.34）显式地表示：
$$\delta_i=\frac{1}{M}log\frac{E_{\tilde{P}}(f_i)}{E_{p}(f_i)}$$
2.Python 的 enumerate() 函数
```python
>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))       # 小标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```
3.defaultdict的使用
计算元组中各个字符串的频数·方法一
```python
strings = ('puppy', 'kitten', 'puppy', 'puppy',
           'weasel', 'puppy', 'kitten', 'puppy')
counts = {}

for kw in strings:
    counts.setdefault(kw, 0)
    counts[kw] += 1 
```
`dict.setdefault()`方法接收两个参数，第一个参数是健的名称，第二个参数是默认值。假如字典中不存在给定的键，则返回参数中提供的默认值；反之，则返回字典中保存的值。
计算元组中各个字符串的频数·方法二
```python
from collections import defaultdict

strings = ('puppy', 'kitten', 'puppy', 'puppy',
           'weasel', 'puppy', 'kitten', 'puppy')
counts = defaultdict(lambda: 0)  # 使用lambda来定义简单的函数

for s in strings:
    counts[s] += 1
    
```

```python
    def build_dict(self):
        self.id2xy = {}
        self.xy2id = {}

        for i, (x, y) in enumerate(self.Pxy):
            self.id2xy[i] = (x, y)
            self.xy2id[(x, y)] = i

    def cal_Pxy_Px(self, X, Y):
        self.Pxy = defaultdict(int)
        self.Px = defaultdict(int)

        for i in range(len(X)):
            x_, y = X[i], Y[i]
            self.Y_.add(y)

            for x in x_:
                self.Pxy[(x, y)] += 1
                self.Px[x] += 1
```